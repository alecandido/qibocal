# -*- coding: utf-8 -*-
import os
import pathlib

import lmfit
import matplotlib.pyplot as plt
import numpy as np
from qibolab.paths import qibolab_folder
from quantify_core.analysis.base_analysis import BaseAnalysis
from quantify_core.data.handling import set_datadir
from scipy.optimize import curve_fit

script_folder = pathlib.Path(__file__).parent

data_folder = qibolab_folder / "calibration" / "data"
data_folder.mkdir(parents=True, exist_ok=True)

quantify_folder = qibolab_folder / "calibration" / "data" / "quantify"
quantify_folder.mkdir(parents=True, exist_ok=True)
set_datadir(quantify_folder)


def lorentzian_fit(label, peak, name):
    # label = directory where hdf5 data file generated by MC is located.
    # label=last --> Read most recent hdf5
    # label=/path/to/directory/ --> read the hdf5 data file contained in "label"

    voltage, x_axis, data, d = data_post(label)
    frequency = x_axis

    # Create a lmfit model for fitting equation defined in resonator_peak
    model_Q = lmfit.Model(resonator_peak)

    # Guess parameters for Lorentzian max or min
    # to guess center
    if peak == max:
        guess_center = frequency[
            np.argmax(voltage)
        ]  # Argmax = Returns the indices of the maximum values along an axis.
    else:
        guess_center = frequency[
            np.argmin(voltage)
        ]  # Argmin = Returns the indices of the minimum values along an axis.

    # to guess the sigma
    if peak == max:
        voltage_min_i = np.argmin(voltage)
        frequency_voltage_min = frequency[voltage_min_i]
        guess_sigma = abs(frequency_voltage_min - guess_center)  # 500KHz*1e-9
    else:
        guess_sigma = 5e-03  # 500KHz*1e-9

    # to guess the amplitude
    if peak == max:
        voltage_max = np.max(voltage)
        guess_amp = voltage_max * guess_sigma * np.pi
    else:
        voltage_min = np.min(voltage)
        guess_amp = -voltage_min * guess_sigma * np.pi

    # to guess the offset
    if peak == max:
        guess_offset = 0
    else:
        guess_offset = voltage[0] * -2.5 * 1e5

    # Add guessed parameters to the model
    if peak == max:
        model_Q.set_param_hint("center", value=guess_center, vary=True)
    else:
        model_Q.set_param_hint("center", value=guess_center, vary=False)
    model_Q.set_param_hint("sigma", value=guess_sigma, vary=True)
    model_Q.set_param_hint("amplitude", value=guess_amp, vary=True)
    model_Q.set_param_hint("offset", value=guess_offset, vary=True)
    guess_parameters = model_Q.make_params()
    guess_parameters

    # fit the model with the data and guessed parameters
    fit_res = model_Q.fit(data=voltage, frequency=frequency, params=guess_parameters)
    # print(fit_res.fit_report())
    # fit_res.best_values
    # get the values for postprocessing and for legend.
    f0 = fit_res.best_values["center"] / 1e9
    BW = (fit_res.best_values["sigma"] * 2) / 1e9
    Q = abs(f0 / BW)

    # plot the fitted curve
    dummy_frequencies = np.linspace(np.amin(frequency), np.amax(frequency), 101)
    fit_fine = resonator_peak(dummy_frequencies, **fit_res.best_values)
    fig, ax = plt.subplots(1, 1, figsize=(8, 3))
    ax.plot(data.x0, data.y0 * 1e3, "o", label="Data")
    ax.plot(
        dummy_frequencies,
        fit_fine * 1e3,
        "r-",
        label=r"Fit $f_0$ ={:.4f} GHz" "\n" "     $Q$ ={:.0f}".format(f0, Q),
    )
    ax.set_ylabel("Integrated Voltage (mV)")
    ax.set_xlabel("Frequency (GHz)")
    ax.legend()
    plt.show()
    fig.savefig(data_folder / f"{name}.pdf", format="pdf")
    # fit_res.plot_fit(show_init=True)
    return f0, BW, Q
